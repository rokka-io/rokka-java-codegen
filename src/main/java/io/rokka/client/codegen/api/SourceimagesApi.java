/*
 * rokka.io
 * digital image processing done right. [Documentation](https://rokka.io/documentation). [Changelog](https://api.rokka.io/changelog.md).
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.rokka.client.codegen.api;

import io.rokka.client.codegen.ApiCallback;
import io.rokka.client.codegen.ApiClient;
import io.rokka.client.codegen.ApiException;
import io.rokka.client.codegen.ApiResponse;
import io.rokka.client.codegen.Configuration;
import io.rokka.client.codegen.Pair;
import io.rokka.client.codegen.ProgressRequestBody;
import io.rokka.client.codegen.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.io.File;
import io.rokka.client.codegen.model.ListSourceImagesResponse;
import io.rokka.client.codegen.model.SourceImage;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SourceimagesApi {
    private ApiClient apiClient;

    public SourceimagesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public SourceimagesApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for copySourceImage
     * @param destination The destination organization (required)
     * @param organization  (required)
     * @param hash  (required)
     * @param overwrite If set to &#39;F&#39;, existing images won&#39;t be overwritten. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#copy-a-source-image-to-another-organization">Copy a single source image to another org. Documentation</a>
     */
    public com.squareup.okhttp.Call copySourceImageCall(String destination, String organization, String hash, String overwrite, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}/{hash}/copy"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()))
            .replaceAll("\\{" + "hash" + "\\}", apiClient.escapeString(hash.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (destination != null)
        localVarHeaderParams.put("Destination", apiClient.parameterToString(destination));
        if (overwrite != null)
        localVarHeaderParams.put("Overwrite", apiClient.parameterToString(overwrite));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call copySourceImageValidateBeforeCall(String destination, String organization, String hash, String overwrite, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'destination' is set
        if (destination == null) {
            throw new ApiException("Missing the required parameter 'destination' when calling copySourceImage(Async)");
        }
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling copySourceImage(Async)");
        }
        
        // verify the required parameter 'hash' is set
        if (hash == null) {
            throw new ApiException("Missing the required parameter 'hash' when calling copySourceImage(Async)");
        }
        

        com.squareup.okhttp.Call call = copySourceImageCall(destination, organization, hash, overwrite, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Copy a single source image to another org.
     * The metadata is copied as well. After copying, changes to either image metadata are not reflected in the other image metadata.  This is a proxy method for COPY on /sourceimages/{organization}/{hash}. It allows to copy images with a POST request, to work around restrictive firewalls and allows to produce a swagger specification for this operation.
     * @param destination The destination organization (required)
     * @param organization  (required)
     * @param hash  (required)
     * @param overwrite If set to &#39;F&#39;, existing images won&#39;t be overwritten. (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#copy-a-source-image-to-another-organization">Copy a single source image to another org. Documentation</a>
     */
    public void copySourceImage(String destination, String organization, String hash, String overwrite) throws ApiException {
        copySourceImageWithHttpInfo(destination, organization, hash, overwrite);
    }

    /**
     * Copy a single source image to another org.
     * The metadata is copied as well. After copying, changes to either image metadata are not reflected in the other image metadata.  This is a proxy method for COPY on /sourceimages/{organization}/{hash}. It allows to copy images with a POST request, to work around restrictive firewalls and allows to produce a swagger specification for this operation.
     * @param destination The destination organization (required)
     * @param organization  (required)
     * @param hash  (required)
     * @param overwrite If set to &#39;F&#39;, existing images won&#39;t be overwritten. (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#copy-a-source-image-to-another-organization">Copy a single source image to another org. Documentation</a>
     */
    public ApiResponse<Void> copySourceImageWithHttpInfo(String destination, String organization, String hash, String overwrite) throws ApiException {
        com.squareup.okhttp.Call call = copySourceImageValidateBeforeCall(destination, organization, hash, overwrite, null, null);
        return apiClient.execute(call);
    }

    /**
     * Copy a single source image to another org. (asynchronously)
     * The metadata is copied as well. After copying, changes to either image metadata are not reflected in the other image metadata.  This is a proxy method for COPY on /sourceimages/{organization}/{hash}. It allows to copy images with a POST request, to work around restrictive firewalls and allows to produce a swagger specification for this operation.
     * @param destination The destination organization (required)
     * @param organization  (required)
     * @param hash  (required)
     * @param overwrite If set to &#39;F&#39;, existing images won&#39;t be overwritten. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#copy-a-source-image-to-another-organization">Copy a single source image to another org. Documentation</a>
     */
    public com.squareup.okhttp.Call copySourceImageAsync(String destination, String organization, String hash, String overwrite, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = copySourceImageValidateBeforeCall(destination, organization, hash, overwrite, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for createSourceImage
     * @param filedata The binary images (required)
     * @param organization  (required)
     * @param metaDynamic JSON metadata about the image, e.g. subject area. See https://rokka.io/documentation/references/dynamic-metadata.html (optional)
     * @param metaUser User specific JSON metadata that can be used when searching source images. See https://rokka.io/documentation/references/user-metadata.html (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#create-a-source-image">Upload new source images. Documentation</a>
     */
    public com.squareup.okhttp.Call createSourceImageCall(File filedata, String organization, String metaDynamic, String metaUser, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        if (filedata != null)
        localVarFormParams.put("filedata", filedata);
        if (metaDynamic != null)
        localVarFormParams.put("meta_dynamic[]", metaDynamic);
        if (metaUser != null)
        localVarFormParams.put("meta_user[]", metaUser);

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call createSourceImageValidateBeforeCall(File filedata, String organization, String metaDynamic, String metaUser, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'filedata' is set
        if (filedata == null) {
            throw new ApiException("Missing the required parameter 'filedata' when calling createSourceImage(Async)");
        }
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling createSourceImage(Async)");
        }
        

        com.squareup.okhttp.Call call = createSourceImageCall(filedata, organization, metaDynamic, metaUser, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Upload new source images.
     * The request is form data for the uploaded files and arrays of metadata. Files and metadata are matched based on their order in the request.  Note that this call allows to upload multiple images, but the swagger UI does not support this.
     * @param filedata The binary images (required)
     * @param organization  (required)
     * @param metaDynamic JSON metadata about the image, e.g. subject area. See https://rokka.io/documentation/references/dynamic-metadata.html (optional)
     * @param metaUser User specific JSON metadata that can be used when searching source images. See https://rokka.io/documentation/references/user-metadata.html (optional)
     * @return ListSourceImagesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#create-a-source-image">Upload new source images. Documentation</a>
     */
    public ListSourceImagesResponse createSourceImage(File filedata, String organization, String metaDynamic, String metaUser) throws ApiException {
        ApiResponse<ListSourceImagesResponse> resp = createSourceImageWithHttpInfo(filedata, organization, metaDynamic, metaUser);
        return resp.getData();
    }

    /**
     * Upload new source images.
     * The request is form data for the uploaded files and arrays of metadata. Files and metadata are matched based on their order in the request.  Note that this call allows to upload multiple images, but the swagger UI does not support this.
     * @param filedata The binary images (required)
     * @param organization  (required)
     * @param metaDynamic JSON metadata about the image, e.g. subject area. See https://rokka.io/documentation/references/dynamic-metadata.html (optional)
     * @param metaUser User specific JSON metadata that can be used when searching source images. See https://rokka.io/documentation/references/user-metadata.html (optional)
     * @return ApiResponse&lt;ListSourceImagesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#create-a-source-image">Upload new source images. Documentation</a>
     */
    public ApiResponse<ListSourceImagesResponse> createSourceImageWithHttpInfo(File filedata, String organization, String metaDynamic, String metaUser) throws ApiException {
        com.squareup.okhttp.Call call = createSourceImageValidateBeforeCall(filedata, organization, metaDynamic, metaUser, null, null);
        Type localVarReturnType = new TypeToken<ListSourceImagesResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Upload new source images. (asynchronously)
     * The request is form data for the uploaded files and arrays of metadata. Files and metadata are matched based on their order in the request.  Note that this call allows to upload multiple images, but the swagger UI does not support this.
     * @param filedata The binary images (required)
     * @param organization  (required)
     * @param metaDynamic JSON metadata about the image, e.g. subject area. See https://rokka.io/documentation/references/dynamic-metadata.html (optional)
     * @param metaUser User specific JSON metadata that can be used when searching source images. See https://rokka.io/documentation/references/user-metadata.html (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#create-a-source-image">Upload new source images. Documentation</a>
     */
    public com.squareup.okhttp.Call createSourceImageAsync(File filedata, String organization, String metaDynamic, String metaUser, final ApiCallback<ListSourceImagesResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = createSourceImageValidateBeforeCall(filedata, organization, metaDynamic, metaUser, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ListSourceImagesResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for createSourceImageMetaDynamicWithName
     * @param metaDynamicDefinition Dynamic Meta Data definition (required)
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @param deletePrevious If the image with the original hash should be deleted (optional, default to false)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/dynamic-metadata.html#add-dynamic-metadata-to-a-source-image">Adds or updates a specific dynamic meta data for an image. Documentation</a>
     */
    public com.squareup.okhttp.Call createSourceImageMetaDynamicWithNameCall(Object metaDynamicDefinition, String organization, String hash, String metaName, Boolean deletePrevious, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = metaDynamicDefinition;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}/{hash}/meta/dynamic/{metaName}"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()))
            .replaceAll("\\{" + "hash" + "\\}", apiClient.escapeString(hash.toString()))
            .replaceAll("\\{" + "metaName" + "\\}", apiClient.escapeString(metaName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (deletePrevious != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("deletePrevious", deletePrevious));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call createSourceImageMetaDynamicWithNameValidateBeforeCall(Object metaDynamicDefinition, String organization, String hash, String metaName, Boolean deletePrevious, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'metaDynamicDefinition' is set
        if (metaDynamicDefinition == null) {
            throw new ApiException("Missing the required parameter 'metaDynamicDefinition' when calling createSourceImageMetaDynamicWithName(Async)");
        }
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling createSourceImageMetaDynamicWithName(Async)");
        }
        
        // verify the required parameter 'hash' is set
        if (hash == null) {
            throw new ApiException("Missing the required parameter 'hash' when calling createSourceImageMetaDynamicWithName(Async)");
        }
        
        // verify the required parameter 'metaName' is set
        if (metaName == null) {
            throw new ApiException("Missing the required parameter 'metaName' when calling createSourceImageMetaDynamicWithName(Async)");
        }
        

        com.squareup.okhttp.Call call = createSourceImageMetaDynamicWithNameCall(metaDynamicDefinition, organization, hash, metaName, deletePrevious, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Adds or updates a specific dynamic meta data for an image.
     * This changes the hash of the image. The response provides the new location of the image in the Location header.
     * @param metaDynamicDefinition Dynamic Meta Data definition (required)
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @param deletePrevious If the image with the original hash should be deleted (optional, default to false)
     * @return SourceImage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/dynamic-metadata.html#add-dynamic-metadata-to-a-source-image">Adds or updates a specific dynamic meta data for an image. Documentation</a>
     */
    public SourceImage createSourceImageMetaDynamicWithName(Object metaDynamicDefinition, String organization, String hash, String metaName, Boolean deletePrevious) throws ApiException {
        ApiResponse<SourceImage> resp = createSourceImageMetaDynamicWithNameWithHttpInfo(metaDynamicDefinition, organization, hash, metaName, deletePrevious);
        return resp.getData();
    }

    /**
     * Adds or updates a specific dynamic meta data for an image.
     * This changes the hash of the image. The response provides the new location of the image in the Location header.
     * @param metaDynamicDefinition Dynamic Meta Data definition (required)
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @param deletePrevious If the image with the original hash should be deleted (optional, default to false)
     * @return ApiResponse&lt;SourceImage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/dynamic-metadata.html#add-dynamic-metadata-to-a-source-image">Adds or updates a specific dynamic meta data for an image. Documentation</a>
     */
    public ApiResponse<SourceImage> createSourceImageMetaDynamicWithNameWithHttpInfo(Object metaDynamicDefinition, String organization, String hash, String metaName, Boolean deletePrevious) throws ApiException {
        com.squareup.okhttp.Call call = createSourceImageMetaDynamicWithNameValidateBeforeCall(metaDynamicDefinition, organization, hash, metaName, deletePrevious, null, null);
        Type localVarReturnType = new TypeToken<SourceImage>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Adds or updates a specific dynamic meta data for an image. (asynchronously)
     * This changes the hash of the image. The response provides the new location of the image in the Location header.
     * @param metaDynamicDefinition Dynamic Meta Data definition (required)
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @param deletePrevious If the image with the original hash should be deleted (optional, default to false)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/dynamic-metadata.html#add-dynamic-metadata-to-a-source-image">Adds or updates a specific dynamic meta data for an image. Documentation</a>
     */
    public com.squareup.okhttp.Call createSourceImageMetaDynamicWithNameAsync(Object metaDynamicDefinition, String organization, String hash, String metaName, Boolean deletePrevious, final ApiCallback<SourceImage> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = createSourceImageMetaDynamicWithNameValidateBeforeCall(metaDynamicDefinition, organization, hash, metaName, deletePrevious, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SourceImage>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for createSourceImageMetaUser
     * @param userMetaData User Meta Data as a json hashmap (required)
     * @param organization  (required)
     * @param hash  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Replace the image meta data with new information. Documentation</a>
     */
    public com.squareup.okhttp.Call createSourceImageMetaUserCall(Object userMetaData, String organization, String hash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = userMetaData;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}/{hash}/meta/user"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()))
            .replaceAll("\\{" + "hash" + "\\}", apiClient.escapeString(hash.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call createSourceImageMetaUserValidateBeforeCall(Object userMetaData, String organization, String hash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'userMetaData' is set
        if (userMetaData == null) {
            throw new ApiException("Missing the required parameter 'userMetaData' when calling createSourceImageMetaUser(Async)");
        }
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling createSourceImageMetaUser(Async)");
        }
        
        // verify the required parameter 'hash' is set
        if (hash == null) {
            throw new ApiException("Missing the required parameter 'hash' when calling createSourceImageMetaUser(Async)");
        }
        

        com.squareup.okhttp.Call call = createSourceImageMetaUserCall(userMetaData, organization, hash, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Replace the image meta data with new information.
     * All existing meta data for the image is removed and then the new meta data is added.  User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     * @param userMetaData User Meta Data as a json hashmap (required)
     * @param organization  (required)
     * @param hash  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Replace the image meta data with new information. Documentation</a>
     */
    public void createSourceImageMetaUser(Object userMetaData, String organization, String hash) throws ApiException {
        createSourceImageMetaUserWithHttpInfo(userMetaData, organization, hash);
    }

    /**
     * Replace the image meta data with new information.
     * All existing meta data for the image is removed and then the new meta data is added.  User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     * @param userMetaData User Meta Data as a json hashmap (required)
     * @param organization  (required)
     * @param hash  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Replace the image meta data with new information. Documentation</a>
     */
    public ApiResponse<Void> createSourceImageMetaUserWithHttpInfo(Object userMetaData, String organization, String hash) throws ApiException {
        com.squareup.okhttp.Call call = createSourceImageMetaUserValidateBeforeCall(userMetaData, organization, hash, null, null);
        return apiClient.execute(call);
    }

    /**
     * Replace the image meta data with new information. (asynchronously)
     * All existing meta data for the image is removed and then the new meta data is added.  User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     * @param userMetaData User Meta Data as a json hashmap (required)
     * @param organization  (required)
     * @param hash  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Replace the image meta data with new information. Documentation</a>
     */
    public com.squareup.okhttp.Call createSourceImageMetaUserAsync(Object userMetaData, String organization, String hash, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = createSourceImageMetaUserValidateBeforeCall(userMetaData, organization, hash, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for createSourceImageMetaUserWthName
     * @param userMetaDataSingleField User Meta Data for a single field in json format (required)
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Adds or updates one user meta data field for an image. Documentation</a>
     */
    public com.squareup.okhttp.Call createSourceImageMetaUserWthNameCall(String userMetaDataSingleField, String organization, String hash, String metaName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = userMetaDataSingleField;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}/{hash}/meta/user/{metaName}"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()))
            .replaceAll("\\{" + "hash" + "\\}", apiClient.escapeString(hash.toString()))
            .replaceAll("\\{" + "metaName" + "\\}", apiClient.escapeString(metaName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call createSourceImageMetaUserWthNameValidateBeforeCall(String userMetaDataSingleField, String organization, String hash, String metaName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'userMetaDataSingleField' is set
        if (userMetaDataSingleField == null) {
            throw new ApiException("Missing the required parameter 'userMetaDataSingleField' when calling createSourceImageMetaUserWthName(Async)");
        }
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling createSourceImageMetaUserWthName(Async)");
        }
        
        // verify the required parameter 'hash' is set
        if (hash == null) {
            throw new ApiException("Missing the required parameter 'hash' when calling createSourceImageMetaUserWthName(Async)");
        }
        
        // verify the required parameter 'metaName' is set
        if (metaName == null) {
            throw new ApiException("Missing the required parameter 'metaName' when calling createSourceImageMetaUserWthName(Async)");
        }
        

        com.squareup.okhttp.Call call = createSourceImageMetaUserWthNameCall(userMetaDataSingleField, organization, hash, metaName, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Adds or updates one user meta data field for an image.
     * User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     * @param userMetaDataSingleField User Meta Data for a single field in json format (required)
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Adds or updates one user meta data field for an image. Documentation</a>
     */
    public void createSourceImageMetaUserWthName(String userMetaDataSingleField, String organization, String hash, String metaName) throws ApiException {
        createSourceImageMetaUserWthNameWithHttpInfo(userMetaDataSingleField, organization, hash, metaName);
    }

    /**
     * Adds or updates one user meta data field for an image.
     * User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     * @param userMetaDataSingleField User Meta Data for a single field in json format (required)
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Adds or updates one user meta data field for an image. Documentation</a>
     */
    public ApiResponse<Void> createSourceImageMetaUserWthNameWithHttpInfo(String userMetaDataSingleField, String organization, String hash, String metaName) throws ApiException {
        com.squareup.okhttp.Call call = createSourceImageMetaUserWthNameValidateBeforeCall(userMetaDataSingleField, organization, hash, metaName, null, null);
        return apiClient.execute(call);
    }

    /**
     * Adds or updates one user meta data field for an image. (asynchronously)
     * User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     * @param userMetaDataSingleField User Meta Data for a single field in json format (required)
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Adds or updates one user meta data field for an image. Documentation</a>
     */
    public com.squareup.okhttp.Call createSourceImageMetaUserWthNameAsync(String userMetaDataSingleField, String organization, String hash, String metaName, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = createSourceImageMetaUserWthNameValidateBeforeCall(userMetaDataSingleField, organization, hash, metaName, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for deleteSourceImage
     * @param organization  (required)
     * @param hash  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#delete-a-source-image">Delete a single source image. Documentation</a>
     */
    public com.squareup.okhttp.Call deleteSourceImageCall(String organization, String hash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}/{hash}"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()))
            .replaceAll("\\{" + "hash" + "\\}", apiClient.escapeString(hash.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call deleteSourceImageValidateBeforeCall(String organization, String hash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling deleteSourceImage(Async)");
        }
        
        // verify the required parameter 'hash' is set
        if (hash == null) {
            throw new ApiException("Missing the required parameter 'hash' when calling deleteSourceImage(Async)");
        }
        

        com.squareup.okhttp.Call call = deleteSourceImageCall(organization, hash, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Delete a single source image.
     * 
     * @param organization  (required)
     * @param hash  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#delete-a-source-image">Delete a single source image. Documentation</a>
     */
    public void deleteSourceImage(String organization, String hash) throws ApiException {
        deleteSourceImageWithHttpInfo(organization, hash);
    }

    /**
     * Delete a single source image.
     * 
     * @param organization  (required)
     * @param hash  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#delete-a-source-image">Delete a single source image. Documentation</a>
     */
    public ApiResponse<Void> deleteSourceImageWithHttpInfo(String organization, String hash) throws ApiException {
        com.squareup.okhttp.Call call = deleteSourceImageValidateBeforeCall(organization, hash, null, null);
        return apiClient.execute(call);
    }

    /**
     * Delete a single source image. (asynchronously)
     * 
     * @param organization  (required)
     * @param hash  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#delete-a-source-image">Delete a single source image. Documentation</a>
     */
    public com.squareup.okhttp.Call deleteSourceImageAsync(String organization, String hash, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = deleteSourceImageValidateBeforeCall(organization, hash, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for deleteSourceImageMetaDynamicWithName
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @param deletePrevious If the image with the original hash should be deleted (optional, default to false)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/dynamic-metadata.html#delete-dynamic-metadata-from-a-source-image">Deletes a specific dynamic meta data. Documentation</a>
     */
    public com.squareup.okhttp.Call deleteSourceImageMetaDynamicWithNameCall(String organization, String hash, String metaName, Boolean deletePrevious, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}/{hash}/meta/dynamic/{metaName}"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()))
            .replaceAll("\\{" + "hash" + "\\}", apiClient.escapeString(hash.toString()))
            .replaceAll("\\{" + "metaName" + "\\}", apiClient.escapeString(metaName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (deletePrevious != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("deletePrevious", deletePrevious));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call deleteSourceImageMetaDynamicWithNameValidateBeforeCall(String organization, String hash, String metaName, Boolean deletePrevious, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling deleteSourceImageMetaDynamicWithName(Async)");
        }
        
        // verify the required parameter 'hash' is set
        if (hash == null) {
            throw new ApiException("Missing the required parameter 'hash' when calling deleteSourceImageMetaDynamicWithName(Async)");
        }
        
        // verify the required parameter 'metaName' is set
        if (metaName == null) {
            throw new ApiException("Missing the required parameter 'metaName' when calling deleteSourceImageMetaDynamicWithName(Async)");
        }
        

        com.squareup.okhttp.Call call = deleteSourceImageMetaDynamicWithNameCall(organization, hash, metaName, deletePrevious, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Deletes a specific dynamic meta data.
     * This changes the hash of the image. The response provides the new location of the image in the Location header.
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @param deletePrevious If the image with the original hash should be deleted (optional, default to false)
     * @return SourceImage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/dynamic-metadata.html#delete-dynamic-metadata-from-a-source-image">Deletes a specific dynamic meta data. Documentation</a>
     */
    public SourceImage deleteSourceImageMetaDynamicWithName(String organization, String hash, String metaName, Boolean deletePrevious) throws ApiException {
        ApiResponse<SourceImage> resp = deleteSourceImageMetaDynamicWithNameWithHttpInfo(organization, hash, metaName, deletePrevious);
        return resp.getData();
    }

    /**
     * Deletes a specific dynamic meta data.
     * This changes the hash of the image. The response provides the new location of the image in the Location header.
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @param deletePrevious If the image with the original hash should be deleted (optional, default to false)
     * @return ApiResponse&lt;SourceImage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/dynamic-metadata.html#delete-dynamic-metadata-from-a-source-image">Deletes a specific dynamic meta data. Documentation</a>
     */
    public ApiResponse<SourceImage> deleteSourceImageMetaDynamicWithNameWithHttpInfo(String organization, String hash, String metaName, Boolean deletePrevious) throws ApiException {
        com.squareup.okhttp.Call call = deleteSourceImageMetaDynamicWithNameValidateBeforeCall(organization, hash, metaName, deletePrevious, null, null);
        Type localVarReturnType = new TypeToken<SourceImage>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Deletes a specific dynamic meta data. (asynchronously)
     * This changes the hash of the image. The response provides the new location of the image in the Location header.
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @param deletePrevious If the image with the original hash should be deleted (optional, default to false)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/dynamic-metadata.html#delete-dynamic-metadata-from-a-source-image">Deletes a specific dynamic meta data. Documentation</a>
     */
    public com.squareup.okhttp.Call deleteSourceImageMetaDynamicWithNameAsync(String organization, String hash, String metaName, Boolean deletePrevious, final ApiCallback<SourceImage> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = deleteSourceImageMetaDynamicWithNameValidateBeforeCall(organization, hash, metaName, deletePrevious, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SourceImage>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for deleteSourceImageMetaUser
     * @param organization  (required)
     * @param hash  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html#delete-metadata-from-a-source-image">Deletes all user meta data. Documentation</a>
     */
    public com.squareup.okhttp.Call deleteSourceImageMetaUserCall(String organization, String hash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}/{hash}/meta/user"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()))
            .replaceAll("\\{" + "hash" + "\\}", apiClient.escapeString(hash.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call deleteSourceImageMetaUserValidateBeforeCall(String organization, String hash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling deleteSourceImageMetaUser(Async)");
        }
        
        // verify the required parameter 'hash' is set
        if (hash == null) {
            throw new ApiException("Missing the required parameter 'hash' when calling deleteSourceImageMetaUser(Async)");
        }
        

        com.squareup.okhttp.Call call = deleteSourceImageMetaUserCall(organization, hash, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Deletes all user meta data.
     * User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     * @param organization  (required)
     * @param hash  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html#delete-metadata-from-a-source-image">Deletes all user meta data. Documentation</a>
     */
    public void deleteSourceImageMetaUser(String organization, String hash) throws ApiException {
        deleteSourceImageMetaUserWithHttpInfo(organization, hash);
    }

    /**
     * Deletes all user meta data.
     * User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     * @param organization  (required)
     * @param hash  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html#delete-metadata-from-a-source-image">Deletes all user meta data. Documentation</a>
     */
    public ApiResponse<Void> deleteSourceImageMetaUserWithHttpInfo(String organization, String hash) throws ApiException {
        com.squareup.okhttp.Call call = deleteSourceImageMetaUserValidateBeforeCall(organization, hash, null, null);
        return apiClient.execute(call);
    }

    /**
     * Deletes all user meta data. (asynchronously)
     * User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     * @param organization  (required)
     * @param hash  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html#delete-metadata-from-a-source-image">Deletes all user meta data. Documentation</a>
     */
    public com.squareup.okhttp.Call deleteSourceImageMetaUserAsync(String organization, String hash, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = deleteSourceImageMetaUserValidateBeforeCall(organization, hash, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for deleteSourceImageMetaUserWithName
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html#delete-metadata-from-a-source-image">Deletes user meta data for a specified field. Documentation</a>
     */
    public com.squareup.okhttp.Call deleteSourceImageMetaUserWithNameCall(String organization, String hash, String metaName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}/{hash}/meta/user/{metaName}"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()))
            .replaceAll("\\{" + "hash" + "\\}", apiClient.escapeString(hash.toString()))
            .replaceAll("\\{" + "metaName" + "\\}", apiClient.escapeString(metaName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call deleteSourceImageMetaUserWithNameValidateBeforeCall(String organization, String hash, String metaName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling deleteSourceImageMetaUserWithName(Async)");
        }
        
        // verify the required parameter 'hash' is set
        if (hash == null) {
            throw new ApiException("Missing the required parameter 'hash' when calling deleteSourceImageMetaUserWithName(Async)");
        }
        
        // verify the required parameter 'metaName' is set
        if (metaName == null) {
            throw new ApiException("Missing the required parameter 'metaName' when calling deleteSourceImageMetaUserWithName(Async)");
        }
        

        com.squareup.okhttp.Call call = deleteSourceImageMetaUserWithNameCall(organization, hash, metaName, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Deletes user meta data for a specified field.
     * User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html#delete-metadata-from-a-source-image">Deletes user meta data for a specified field. Documentation</a>
     */
    public void deleteSourceImageMetaUserWithName(String organization, String hash, String metaName) throws ApiException {
        deleteSourceImageMetaUserWithNameWithHttpInfo(organization, hash, metaName);
    }

    /**
     * Deletes user meta data for a specified field.
     * User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html#delete-metadata-from-a-source-image">Deletes user meta data for a specified field. Documentation</a>
     */
    public ApiResponse<Void> deleteSourceImageMetaUserWithNameWithHttpInfo(String organization, String hash, String metaName) throws ApiException {
        com.squareup.okhttp.Call call = deleteSourceImageMetaUserWithNameValidateBeforeCall(organization, hash, metaName, null, null);
        return apiClient.execute(call);
    }

    /**
     * Deletes user meta data for a specified field. (asynchronously)
     * User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html#delete-metadata-from-a-source-image">Deletes user meta data for a specified field. Documentation</a>
     */
    public com.squareup.okhttp.Call deleteSourceImageMetaUserWithNameAsync(String organization, String hash, String metaName, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = deleteSourceImageMetaUserWithNameValidateBeforeCall(organization, hash, metaName, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for downloadSourceImage
     * @param organization  (required)
     * @param hash  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#downloading-a-source-image">Download original source image binary. Documentation</a>
     */
    public com.squareup.okhttp.Call downloadSourceImageCall(String organization, String hash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}/{hash}/download"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()))
            .replaceAll("\\{" + "hash" + "\\}", apiClient.escapeString(hash.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call downloadSourceImageValidateBeforeCall(String organization, String hash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling downloadSourceImage(Async)");
        }
        
        // verify the required parameter 'hash' is set
        if (hash == null) {
            throw new ApiException("Missing the required parameter 'hash' when calling downloadSourceImage(Async)");
        }
        

        com.squareup.okhttp.Call call = downloadSourceImageCall(organization, hash, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Download original source image binary.
     * 
     * @param organization  (required)
     * @param hash  (required)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#downloading-a-source-image">Download original source image binary. Documentation</a>
     */
    public File downloadSourceImage(String organization, String hash) throws ApiException {
        ApiResponse<File> resp = downloadSourceImageWithHttpInfo(organization, hash);
        return resp.getData();
    }

    /**
     * Download original source image binary.
     * 
     * @param organization  (required)
     * @param hash  (required)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#downloading-a-source-image">Download original source image binary. Documentation</a>
     */
    public ApiResponse<File> downloadSourceImageWithHttpInfo(String organization, String hash) throws ApiException {
        com.squareup.okhttp.Call call = downloadSourceImageValidateBeforeCall(organization, hash, null, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Download original source image binary. (asynchronously)
     * 
     * @param organization  (required)
     * @param hash  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#downloading-a-source-image">Download original source image binary. Documentation</a>
     */
    public com.squareup.okhttp.Call downloadSourceImageAsync(String organization, String hash, final ApiCallback<File> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = downloadSourceImageValidateBeforeCall(organization, hash, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getSourceImage
     * @param organization  (required)
     * @param hash  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#retrieve-data-about-a-source-image">Get information about a source image. Documentation</a>
     */
    public com.squareup.okhttp.Call getSourceImageCall(String organization, String hash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}/{hash}"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()))
            .replaceAll("\\{" + "hash" + "\\}", apiClient.escapeString(hash.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getSourceImageValidateBeforeCall(String organization, String hash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling getSourceImage(Async)");
        }
        
        // verify the required parameter 'hash' is set
        if (hash == null) {
            throw new ApiException("Missing the required parameter 'hash' when calling getSourceImage(Async)");
        }
        

        com.squareup.okhttp.Call call = getSourceImageCall(organization, hash, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get information about a source image.
     * 
     * @param organization  (required)
     * @param hash  (required)
     * @return SourceImage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#retrieve-data-about-a-source-image">Get information about a source image. Documentation</a>
     */
    public SourceImage getSourceImage(String organization, String hash) throws ApiException {
        ApiResponse<SourceImage> resp = getSourceImageWithHttpInfo(organization, hash);
        return resp.getData();
    }

    /**
     * Get information about a source image.
     * 
     * @param organization  (required)
     * @param hash  (required)
     * @return ApiResponse&lt;SourceImage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#retrieve-data-about-a-source-image">Get information about a source image. Documentation</a>
     */
    public ApiResponse<SourceImage> getSourceImageWithHttpInfo(String organization, String hash) throws ApiException {
        com.squareup.okhttp.Call call = getSourceImageValidateBeforeCall(organization, hash, null, null);
        Type localVarReturnType = new TypeToken<SourceImage>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get information about a source image. (asynchronously)
     * 
     * @param organization  (required)
     * @param hash  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#retrieve-data-about-a-source-image">Get information about a source image. Documentation</a>
     */
    public com.squareup.okhttp.Call getSourceImageAsync(String organization, String hash, final ApiCallback<SourceImage> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getSourceImageValidateBeforeCall(organization, hash, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SourceImage>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getSourceImageMetaUser
     * @param organization  (required)
     * @param hash  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Get all user meta data. Documentation</a>
     */
    public com.squareup.okhttp.Call getSourceImageMetaUserCall(String organization, String hash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}/{hash}/meta/user"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()))
            .replaceAll("\\{" + "hash" + "\\}", apiClient.escapeString(hash.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getSourceImageMetaUserValidateBeforeCall(String organization, String hash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling getSourceImageMetaUser(Async)");
        }
        
        // verify the required parameter 'hash' is set
        if (hash == null) {
            throw new ApiException("Missing the required parameter 'hash' when calling getSourceImageMetaUser(Async)");
        }
        

        com.squareup.okhttp.Call call = getSourceImageMetaUserCall(organization, hash, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get all user meta data.
     * 
     * @param organization  (required)
     * @param hash  (required)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Get all user meta data. Documentation</a>
     */
    public Object getSourceImageMetaUser(String organization, String hash) throws ApiException {
        ApiResponse<Object> resp = getSourceImageMetaUserWithHttpInfo(organization, hash);
        return resp.getData();
    }

    /**
     * Get all user meta data.
     * 
     * @param organization  (required)
     * @param hash  (required)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Get all user meta data. Documentation</a>
     */
    public ApiResponse<Object> getSourceImageMetaUserWithHttpInfo(String organization, String hash) throws ApiException {
        com.squareup.okhttp.Call call = getSourceImageMetaUserValidateBeforeCall(organization, hash, null, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get all user meta data. (asynchronously)
     * 
     * @param organization  (required)
     * @param hash  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Get all user meta data. Documentation</a>
     */
    public com.squareup.okhttp.Call getSourceImageMetaUserAsync(String organization, String hash, final ApiCallback<Object> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getSourceImageMetaUserValidateBeforeCall(organization, hash, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getSourceImageMetaUserWithName
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Get user meta for a specific field. Documentation</a>
     */
    public com.squareup.okhttp.Call getSourceImageMetaUserWithNameCall(String organization, String hash, String metaName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}/{hash}/meta/user/{metaName}"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()))
            .replaceAll("\\{" + "hash" + "\\}", apiClient.escapeString(hash.toString()))
            .replaceAll("\\{" + "metaName" + "\\}", apiClient.escapeString(metaName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getSourceImageMetaUserWithNameValidateBeforeCall(String organization, String hash, String metaName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling getSourceImageMetaUserWithName(Async)");
        }
        
        // verify the required parameter 'hash' is set
        if (hash == null) {
            throw new ApiException("Missing the required parameter 'hash' when calling getSourceImageMetaUserWithName(Async)");
        }
        
        // verify the required parameter 'metaName' is set
        if (metaName == null) {
            throw new ApiException("Missing the required parameter 'metaName' when calling getSourceImageMetaUserWithName(Async)");
        }
        

        com.squareup.okhttp.Call call = getSourceImageMetaUserWithNameCall(organization, hash, metaName, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get user meta for a specific field.
     * 
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Get user meta for a specific field. Documentation</a>
     */
    public String getSourceImageMetaUserWithName(String organization, String hash, String metaName) throws ApiException {
        ApiResponse<String> resp = getSourceImageMetaUserWithNameWithHttpInfo(organization, hash, metaName);
        return resp.getData();
    }

    /**
     * Get user meta for a specific field.
     * 
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Get user meta for a specific field. Documentation</a>
     */
    public ApiResponse<String> getSourceImageMetaUserWithNameWithHttpInfo(String organization, String hash, String metaName) throws ApiException {
        com.squareup.okhttp.Call call = getSourceImageMetaUserWithNameValidateBeforeCall(organization, hash, metaName, null, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get user meta for a specific field. (asynchronously)
     * 
     * @param organization  (required)
     * @param hash  (required)
     * @param metaName  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Get user meta for a specific field. Documentation</a>
     */
    public com.squareup.okhttp.Call getSourceImageMetaUserWithNameAsync(String organization, String hash, String metaName, final ApiCallback<String> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getSourceImageMetaUserWithNameValidateBeforeCall(organization, hash, metaName, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for listSourceImages
     * @param organization  (required)
     * @param offset When paging results, where to start or a cursor (optional, default to 0)
     * @param limit How many images should be returned (optional, default to 100)
     * @param sort The field to be used for sorting (optional, default to created desc)
     * @param deleted Search for deleted images (optional, default to false)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/searching-images.html">Get all images of an organization, with paging. Documentation</a>
     */
    public com.squareup.okhttp.Call listSourceImagesCall(String organization, String offset, Integer limit, String sort, Boolean deleted, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (offset != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("offset", offset));
        if (limit != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
        if (sort != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort", sort));
        if (deleted != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("deleted", deleted));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call listSourceImagesValidateBeforeCall(String organization, String offset, Integer limit, String sort, Boolean deleted, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling listSourceImages(Async)");
        }
        

        com.squareup.okhttp.Call call = listSourceImagesCall(organization, offset, limit, sort, deleted, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get all images of an organization, with paging.
     * You can also filter and sort by their metadata. See the API reference for more in depth documentation about this.
     * @param organization  (required)
     * @param offset When paging results, where to start or a cursor (optional, default to 0)
     * @param limit How many images should be returned (optional, default to 100)
     * @param sort The field to be used for sorting (optional, default to created desc)
     * @param deleted Search for deleted images (optional, default to false)
     * @return ListSourceImagesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/searching-images.html">Get all images of an organization, with paging. Documentation</a>
     */
    public ListSourceImagesResponse listSourceImages(String organization, String offset, Integer limit, String sort, Boolean deleted) throws ApiException {
        ApiResponse<ListSourceImagesResponse> resp = listSourceImagesWithHttpInfo(organization, offset, limit, sort, deleted);
        return resp.getData();
    }

    /**
     * Get all images of an organization, with paging.
     * You can also filter and sort by their metadata. See the API reference for more in depth documentation about this.
     * @param organization  (required)
     * @param offset When paging results, where to start or a cursor (optional, default to 0)
     * @param limit How many images should be returned (optional, default to 100)
     * @param sort The field to be used for sorting (optional, default to created desc)
     * @param deleted Search for deleted images (optional, default to false)
     * @return ApiResponse&lt;ListSourceImagesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/searching-images.html">Get all images of an organization, with paging. Documentation</a>
     */
    public ApiResponse<ListSourceImagesResponse> listSourceImagesWithHttpInfo(String organization, String offset, Integer limit, String sort, Boolean deleted) throws ApiException {
        com.squareup.okhttp.Call call = listSourceImagesValidateBeforeCall(organization, offset, limit, sort, deleted, null, null);
        Type localVarReturnType = new TypeToken<ListSourceImagesResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get all images of an organization, with paging. (asynchronously)
     * You can also filter and sort by their metadata. See the API reference for more in depth documentation about this.
     * @param organization  (required)
     * @param offset When paging results, where to start or a cursor (optional, default to 0)
     * @param limit How many images should be returned (optional, default to 100)
     * @param sort The field to be used for sorting (optional, default to created desc)
     * @param deleted Search for deleted images (optional, default to false)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/searching-images.html">Get all images of an organization, with paging. Documentation</a>
     */
    public com.squareup.okhttp.Call listSourceImagesAsync(String organization, String offset, Integer limit, String sort, Boolean deleted, final ApiCallback<ListSourceImagesResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = listSourceImagesValidateBeforeCall(organization, offset, limit, sort, deleted, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ListSourceImagesResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for listSourceImagesByBinaryHash
     * @param organization  (required)
     * @param binaryHash  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#finding-with-binary-hash">Get all images in this organization that match a binaryhash. Documentation</a>
     */
    public com.squareup.okhttp.Call listSourceImagesByBinaryHashCall(String organization, String binaryHash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}/binaryhash/{binaryHash}"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()))
            .replaceAll("\\{" + "binaryHash" + "\\}", apiClient.escapeString(binaryHash.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call listSourceImagesByBinaryHashValidateBeforeCall(String organization, String binaryHash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling listSourceImagesByBinaryHash(Async)");
        }
        
        // verify the required parameter 'binaryHash' is set
        if (binaryHash == null) {
            throw new ApiException("Missing the required parameter 'binaryHash' when calling listSourceImagesByBinaryHash(Async)");
        }
        

        com.squareup.okhttp.Call call = listSourceImagesByBinaryHashCall(organization, binaryHash, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get all images in this organization that match a binaryhash.
     * The binary hash is the sha1 of the image binary. This may yield several results if the same image has been uploaded with varying dynamic metadata.
     * @param organization  (required)
     * @param binaryHash  (required)
     * @return ListSourceImagesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#finding-with-binary-hash">Get all images in this organization that match a binaryhash. Documentation</a>
     */
    public ListSourceImagesResponse listSourceImagesByBinaryHash(String organization, String binaryHash) throws ApiException {
        ApiResponse<ListSourceImagesResponse> resp = listSourceImagesByBinaryHashWithHttpInfo(organization, binaryHash);
        return resp.getData();
    }

    /**
     * Get all images in this organization that match a binaryhash.
     * The binary hash is the sha1 of the image binary. This may yield several results if the same image has been uploaded with varying dynamic metadata.
     * @param organization  (required)
     * @param binaryHash  (required)
     * @return ApiResponse&lt;ListSourceImagesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#finding-with-binary-hash">Get all images in this organization that match a binaryhash. Documentation</a>
     */
    public ApiResponse<ListSourceImagesResponse> listSourceImagesByBinaryHashWithHttpInfo(String organization, String binaryHash) throws ApiException {
        com.squareup.okhttp.Call call = listSourceImagesByBinaryHashValidateBeforeCall(organization, binaryHash, null, null);
        Type localVarReturnType = new TypeToken<ListSourceImagesResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get all images in this organization that match a binaryhash. (asynchronously)
     * The binary hash is the sha1 of the image binary. This may yield several results if the same image has been uploaded with varying dynamic metadata.
     * @param organization  (required)
     * @param binaryHash  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#finding-with-binary-hash">Get all images in this organization that match a binaryhash. Documentation</a>
     */
    public com.squareup.okhttp.Call listSourceImagesByBinaryHashAsync(String organization, String binaryHash, final ApiCallback<ListSourceImagesResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = listSourceImagesByBinaryHashValidateBeforeCall(organization, binaryHash, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ListSourceImagesResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for patchSourceImageMetaUser
     * @param userMetaData User Meta Data as a json hashmap (required)
     * @param organization  (required)
     * @param hash  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Update the specified meta data fields for an image. Documentation</a>
     */
    public com.squareup.okhttp.Call patchSourceImageMetaUserCall(Object userMetaData, String organization, String hash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = userMetaData;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}/{hash}/meta/user"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()))
            .replaceAll("\\{" + "hash" + "\\}", apiClient.escapeString(hash.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call patchSourceImageMetaUserValidateBeforeCall(Object userMetaData, String organization, String hash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'userMetaData' is set
        if (userMetaData == null) {
            throw new ApiException("Missing the required parameter 'userMetaData' when calling patchSourceImageMetaUser(Async)");
        }
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling patchSourceImageMetaUser(Async)");
        }
        
        // verify the required parameter 'hash' is set
        if (hash == null) {
            throw new ApiException("Missing the required parameter 'hash' when calling patchSourceImageMetaUser(Async)");
        }
        

        com.squareup.okhttp.Call call = patchSourceImageMetaUserCall(userMetaData, organization, hash, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Update the specified meta data fields for an image.
     * This only overwrites the fields specified in the request, but leaves existing meta data with different names unchanged.  User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     * @param userMetaData User Meta Data as a json hashmap (required)
     * @param organization  (required)
     * @param hash  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Update the specified meta data fields for an image. Documentation</a>
     */
    public void patchSourceImageMetaUser(Object userMetaData, String organization, String hash) throws ApiException {
        patchSourceImageMetaUserWithHttpInfo(userMetaData, organization, hash);
    }

    /**
     * Update the specified meta data fields for an image.
     * This only overwrites the fields specified in the request, but leaves existing meta data with different names unchanged.  User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     * @param userMetaData User Meta Data as a json hashmap (required)
     * @param organization  (required)
     * @param hash  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Update the specified meta data fields for an image. Documentation</a>
     */
    public ApiResponse<Void> patchSourceImageMetaUserWithHttpInfo(Object userMetaData, String organization, String hash) throws ApiException {
        com.squareup.okhttp.Call call = patchSourceImageMetaUserValidateBeforeCall(userMetaData, organization, hash, null, null);
        return apiClient.execute(call);
    }

    /**
     * Update the specified meta data fields for an image. (asynchronously)
     * This only overwrites the fields specified in the request, but leaves existing meta data with different names unchanged.  User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     * @param userMetaData User Meta Data as a json hashmap (required)
     * @param organization  (required)
     * @param hash  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/user-metadata.html">Update the specified meta data fields for an image. Documentation</a>
     */
    public com.squareup.okhttp.Call patchSourceImageMetaUserAsync(Object userMetaData, String organization, String hash, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = patchSourceImageMetaUserValidateBeforeCall(userMetaData, organization, hash, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for restoreSourceImage
     * @param organization  (required)
     * @param hash  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#restore-a-source-image">Restore source image including previously set metadata. Documentation</a>
     */
    public com.squareup.okhttp.Call restoreSourceImageCall(String organization, String hash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sourceimages/{organization}/{hash}/restore"
            .replaceAll("\\{" + "organization" + "\\}", apiClient.escapeString(organization.toString()))
            .replaceAll("\\{" + "hash" + "\\}", apiClient.escapeString(hash.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call restoreSourceImageValidateBeforeCall(String organization, String hash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'organization' is set
        if (organization == null) {
            throw new ApiException("Missing the required parameter 'organization' when calling restoreSourceImage(Async)");
        }
        
        // verify the required parameter 'hash' is set
        if (hash == null) {
            throw new ApiException("Missing the required parameter 'hash' when calling restoreSourceImage(Async)");
        }
        

        com.squareup.okhttp.Call call = restoreSourceImageCall(organization, hash, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Restore source image including previously set metadata.
     * If the image has been deleted but not yet purged from the system, it is restored. If an image with this hash already exists and is not deleted, information about that image is returned.
     * @param organization  (required)
     * @param hash  (required)
     * @return SourceImage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#restore-a-source-image">Restore source image including previously set metadata. Documentation</a>
     */
    public SourceImage restoreSourceImage(String organization, String hash) throws ApiException {
        ApiResponse<SourceImage> resp = restoreSourceImageWithHttpInfo(organization, hash);
        return resp.getData();
    }

    /**
     * Restore source image including previously set metadata.
     * If the image has been deleted but not yet purged from the system, it is restored. If an image with this hash already exists and is not deleted, information about that image is returned.
     * @param organization  (required)
     * @param hash  (required)
     * @return ApiResponse&lt;SourceImage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#restore-a-source-image">Restore source image including previously set metadata. Documentation</a>
     */
    public ApiResponse<SourceImage> restoreSourceImageWithHttpInfo(String organization, String hash) throws ApiException {
        com.squareup.okhttp.Call call = restoreSourceImageValidateBeforeCall(organization, hash, null, null);
        Type localVarReturnType = new TypeToken<SourceImage>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Restore source image including previously set metadata. (asynchronously)
     * If the image has been deleted but not yet purged from the system, it is restored. If an image with this hash already exists and is not deleted, information about that image is returned.
     * @param organization  (required)
     * @param hash  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * 
     * @see <a href="https://rokka.io/documentation/references/source-images.html#restore-a-source-image">Restore source image including previously set metadata. Documentation</a>
     */
    public com.squareup.okhttp.Call restoreSourceImageAsync(String organization, String hash, final ApiCallback<SourceImage> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = restoreSourceImageValidateBeforeCall(organization, hash, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SourceImage>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
