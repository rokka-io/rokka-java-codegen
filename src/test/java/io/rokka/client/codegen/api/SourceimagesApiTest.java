/*
 * rokka.io
 * digital image processing done right. [Documentation](https://rokka.io/documentation). [Changelog](https://api.rokka.io/changelog.md).
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.rokka.client.codegen.api;

import io.rokka.client.codegen.ApiException;
import java.io.File;
import io.rokka.client.codegen.model.ListSourceImagesResponse;
import io.rokka.client.codegen.model.SourceImage;
import org.junit.Test;
import org.junit.Ignore;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for SourceimagesApi
 */
@Ignore
public class SourceimagesApiTest {

    private final SourceimagesApi api = new SourceimagesApi();

    
    /**
     * Upload new source images.
     *
     * The request is form data for the uploaded files and arrays of metadata. Files and metadata are matched based on their order in the request.  Note that this call allows to upload multiple images, but the swagger UI does not support this.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void createSourceImageTest() throws ApiException {
        File filedata = null;
        String organization = null;
        String metaDynamic = null;
        String metaUser = null;
        ListSourceImagesResponse response = api.createSourceImage(filedata, organization, metaDynamic, metaUser);

        // TODO: test validations
    }
    
    /**
     * Adds or updates a specific dynamic meta data for an image.
     *
     * This changes the hash of the image. The response provides the new location of the image in the Location header.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void createSourceImageMetaDynamicWithNameTest() throws ApiException {
        Object metaDynamicDefinition = null;
        String organization = null;
        String hash = null;
        String metaName = null;
        Boolean deletePrevious = null;
        SourceImage response = api.createSourceImageMetaDynamicWithName(metaDynamicDefinition, organization, hash, metaName, deletePrevious);

        // TODO: test validations
    }
    
    /**
     * Replace the image meta data with new information.
     *
     * All existing meta data for the image is removed and then the new meta data is added.  User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void createSourceImageMetaUserTest() throws ApiException {
        Object userMetaData = null;
        String organization = null;
        String hash = null;
        api.createSourceImageMetaUser(userMetaData, organization, hash);

        // TODO: test validations
    }
    
    /**
     * Adds or updates one user meta data field for an image.
     *
     * User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void createSourceImageMetaUserWthNameTest() throws ApiException {
        String userMetaDataSingleField = null;
        String organization = null;
        String hash = null;
        String metaName = null;
        api.createSourceImageMetaUserWthName(userMetaDataSingleField, organization, hash, metaName);

        // TODO: test validations
    }
    
    /**
     * Delete a single source image.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void deleteSourceImageTest() throws ApiException {
        String organization = null;
        String hash = null;
        api.deleteSourceImage(organization, hash);

        // TODO: test validations
    }
    
    /**
     * Deletes a specific dynamic meta data.
     *
     * This changes the hash of the image. The response provides the new location of the image in the Location header.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void deleteSourceImageMetaDynamicWithNameTest() throws ApiException {
        String organization = null;
        String hash = null;
        String metaName = null;
        Boolean deletePrevious = null;
        SourceImage response = api.deleteSourceImageMetaDynamicWithName(organization, hash, metaName, deletePrevious);

        // TODO: test validations
    }
    
    /**
     * Deletes all user meta data.
     *
     * User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void deleteSourceImageMetaUserTest() throws ApiException {
        String organization = null;
        String hash = null;
        api.deleteSourceImageMetaUser(organization, hash);

        // TODO: test validations
    }
    
    /**
     * Deletes user meta data for a specified field.
     *
     * User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void deleteSourceImageMetaUserWithNameTest() throws ApiException {
        String organization = null;
        String hash = null;
        String metaName = null;
        api.deleteSourceImageMetaUserWithName(organization, hash, metaName);

        // TODO: test validations
    }
    
    /**
     * Download original source image binary.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void downloadSourceImageTest() throws ApiException {
        String organization = null;
        String hash = null;
        File response = api.downloadSourceImage(organization, hash);

        // TODO: test validations
    }
    
    /**
     * Get information about a source image.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getSourceImageTest() throws ApiException {
        String organization = null;
        String hash = null;
        SourceImage response = api.getSourceImage(organization, hash);

        // TODO: test validations
    }
    
    /**
     * Get all user meta data.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getSourceImageMetaUserTest() throws ApiException {
        String organization = null;
        String hash = null;
        Object response = api.getSourceImageMetaUser(organization, hash);

        // TODO: test validations
    }
    
    /**
     * Get user meta for a specific field.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getSourceImageMetaUserWithNameTest() throws ApiException {
        String organization = null;
        String hash = null;
        String metaName = null;
        String response = api.getSourceImageMetaUserWithName(organization, hash, metaName);

        // TODO: test validations
    }
    
    /**
     * Get all images of an organization, with paging.
     *
     * You can also filter and sort by their metadata. See the API reference for more in depth documentation about this.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void listSourceImagesTest() throws ApiException {
        String organization = null;
        String offset = null;
        Integer limit = null;
        String sort = null;
        Boolean deleted = null;
        ListSourceImagesResponse response = api.listSourceImages(organization, offset, limit, sort, deleted);

        // TODO: test validations
    }
    
    /**
     * Get all images in this organization that match a binaryhash.
     *
     * The binary hash is the sha1 of the image binary. This may yield several results if the same image has been uploaded with varying dynamic metadata.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void listSourceImagesByBinaryHashTest() throws ApiException {
        String organization = null;
        String binaryHash = null;
        ListSourceImagesResponse response = api.listSourceImagesByBinaryHash(organization, binaryHash);

        // TODO: test validations
    }
    
    /**
     * Update the specified meta data fields for an image.
     *
     * This only overwrites the fields specified in the request, but leaves existing meta data with different names unchanged.  User metadata is used for searching images that have been stored in rokka. It will never lead to differences in the output image and thus changing it never leads to a new hash.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void patchSourceImageMetaUserTest() throws ApiException {
        Object userMetaData = null;
        String organization = null;
        String hash = null;
        api.patchSourceImageMetaUser(userMetaData, organization, hash);

        // TODO: test validations
    }
    
    /**
     * Restore source image including previously set metadata.
     *
     * If the image has been deleted but not yet purged from the system, it is restored. If an image with this hash already exists and is not deleted, information about that image is returned.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void restoreSourceImageTest() throws ApiException {
        String organization = null;
        String hash = null;
        SourceImage response = api.restoreSourceImage(organization, hash);

        // TODO: test validations
    }
    
    /**
     * Copy a single source image to another org.
     *
     * The metadata is copied as well. After copying, changes to either image metadata are not reflected in the other image metadata.  This is a proxy method for COPY on /sourceimages/{organization}/{hash}. It allows to copy images with a POST request, to work around restrictive firewalls and allows to produce a swagger specification for this operation.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void sourceimagesOrganizationHashCopyPostTest() throws ApiException {
        String destination = null;
        String organization = null;
        String hash = null;
        String overwrite = null;
        api.sourceimagesOrganizationHashCopyPost(destination, organization, hash, overwrite);

        // TODO: test validations
    }
    
}
